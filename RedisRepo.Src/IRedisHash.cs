using System;
using System.Linq.Expressions;
using System.Threading.Tasks;

using StackExchange.Redis;

namespace RedisRepo.Src
{
	public interface IRedisHash<T> where T : class
	{
		bool FlattenCollections { get; set; }

		/// <summary>
		///     Function that takes in the object and returns the value of the primary Id of that object. The default
		///     implementation of this reflects over the object and looks for properties that are named Id, [Type-Name]Id,
		///     or EntityId (in that order). If it doesn't find anything like that an exception is thrown.
		/// </summary>
		Func<T, string> PrimaryEntityId { get; set; }

		IDatabase RedisDatabase { get; }

		/// <summary>
		///		<para>
		///			Takes the given entity and converts its public properties into a redis hash and saves it to redis.
		///		</para>
		///		<para>
		///			The key is generated by calling the <see cref="PrimaryEntityId"/> Func property.
		///		</para>
		/// </summary>
		/// <param name="entity"></param>
		/// <returns></returns>
		Task SetAllAsync(T entity);

		///  <summary>
		/// 	Gets a redis hash at the given key and deserializes it into a type of <see cref="T"/>
		///  </summary>
		Task<T> GetAllAsync(string entityId);

		/// <summary>
		///		Deletes the redis hash at the key equivalent to what the <see cref="PrimaryEntityId"/> produces.
		/// </summary>
		/// <param name="entity"></param>
		Task DeleteAsync(T entity);

		///  <summary>
		/// 		Gets a strongly typed hash value based on the evaluation of the <see cref="propertyExpression"/>. The 
		/// 		redis key is produced by the <see cref="PrimaryEntityId"/>.
		///  </summary>
		/// <param name="propertyExpression">Func expression that gets a property name.</param>
		Task<TFieldValue> GetFieldVaueAsync<TFieldValue>(Expression<Func<T, object>> propertyExpression);

		/// <summary>
		///		Gets the hash value at the given redis key and hash name.
		/// </summary>
		Task<TFieldValue> GetFieldVaueAsync<TFieldValue>(string redisKey, string hashName);

		/// <summary>
		///		Sets a redis hash value at the hash name that is the same name as the given property name
		///		as a result of evaluating the <see cref="propertyExpression"/>.
		/// </summary>
		/// <param name="propertyExpression"></param>
		/// <returns></returns>
		Task SetFieldValueAsync(Expression<Func<T, object>> propertyExpression);

		/// <summary>
		/// Checks if the hash exists at a redis key that will be composed from calling <see cref="ComposePrimaryCacheKey"/>
		/// with the entity Id property used as the unique identifier.
		/// </summary>
		/// <returns></returns>
		Task<bool> ExistsAsync(T entity);

		/// <summary>
		/// Checks if the hash exists at the given redisKey.
		/// </summary>
		/// <param name="redisKey"></param>
		/// <returns></returns>
		Task<bool> ExistsAsync(string redisKey);

		/// <summary>
		/// Composes the primary cache key used for setting the redis hash. The key returned would be similar
		/// to "ObjectHash:[TypeName]:[EntityId]" with the "TypeName" being a call to typeof(T).Name and the 
		/// "EntityId" being the given <see cref="entityId"/>.
		/// </summary>
		/// <param name="entityId"></param>
		/// <returns></returns>
		string ComposePrimaryCacheKey(string entityId);

		string ComposeCollectionHashFieldName(string propertyName, string collectionKey);
	}
}