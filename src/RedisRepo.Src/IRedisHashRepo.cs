using System;
using System.Linq.Expressions;
using System.Threading.Tasks;

using StackExchange.Redis;

namespace RedisRepo.Src
{
	public interface IRedisHash<T> where T : class
	{
		bool FlattenDictionaries { get; set; }

		/// <summary>
		///     Function that takes in the object and returns the value of the primary Id of that object. The default
		///     implementation of this reflects over the object and looks for properties that are named Id, [Type-Name]Id,
		///     or EntityId (in that order). If it doesn't find anything like that an exception is thrown.
		/// </summary>
		Func<T, string> PrimaryEntityIdLocator { get; set; }

		Func<string, string> PrimaryCacheKeyFormatter { get; set; }

		IDatabase RedisDatabase { get; }

		/// <summary>
		///		<para>
		///			Takes the given entity and converts its public properties into a redis hash and saves it to redis.
		///		</para>
		///		<para>
		///			The key is generated by calling the <see cref="PrimaryEntityIdLocator"/> Func property.
		///		</para>
		/// </summary>
		/// <param name="entity"></param>
		/// <returns></returns>
		Task SetAllAsync(T entity);

		///  <summary>
		/// 	Gets a redis hash at the given key and deserializes it into a type of <see cref="T"/>
		///  </summary>
		Task<T> GetAllAsync(string entityId);

		/// <summary>
		///		Deletes the redis hash at the key equivalent to what the <see cref="PrimaryEntityIdLocator"/> produces.
		/// </summary>
		/// <param name="entity"></param>
		Task DeleteAsync(T entity);

		/// <summary>
		/// Deletes the redis hash at the given entity ID.
		/// </summary>
		/// <param name="entityId"></param>
		/// <returns></returns>
		Task DeleteAsync(string entityId);

		///  <summary>
		/// 		Gets a strongly typed hash value based on the evaluation of the <see cref="propertyExpression"/>. The 
		/// 		redis key is produced by the <see cref="PrimaryEntityIdLocator"/>.
		///  </summary>
		/// <param name="entityId"></param>
		/// <param name="propertyExpression">Func expression that gets a property name.</param>
		Task<TFieldValue> GetFieldVaueAsync<TFieldValue>(string entityId, Expression<Func<T, TFieldValue>> propertyExpression);

		/// <summary>
		///		Gets the hash value at the given redis key and hash name.
		/// </summary>
		Task<TFieldValue> GetFieldVaueAsync<TFieldValue>(string entityId, string hashName);

		///  <summary>
		/// 		Sets a redis hash value at the hash name that is the same name as the given property name
		/// 		as a result of evaluating the <see cref="propertyExpression"/>.
		///  </summary>
		/// <param name="entityId"></param>
		/// <param name="propertyExpression"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		Task SetFieldValueAsync<TFieldValue>(string entityId, Expression<Func<T, TFieldValue>> propertyExpression, TFieldValue value);

		/// <summary>
		/// Checks if the hash exists at a redis key that will be composed from calling <see cref="DefaultPrimaryCacheKeyFormatter"/>
		/// with the entity Id property used as the unique identifier.
		/// </summary>
		/// <returns></returns>
		Task<bool> ExistsAsync(T entity);

		/// <summary>
		/// Checks if the hash exists at the given entityId.
		/// </summary>
		/// <param name="entityId"></param>
		/// <returns></returns>
		Task<bool> ExistsAsync(string entityId);

		Func<string, string, string> DictionaryHashFieldNameFormatter { get; set; }

		///  <summary>
		/// 		Gets the value for a dictionary stored at the given <see cref="dictionaryKey"/>
		///  </summary>
		///  <typeparam name="TKey"></typeparam>
		///  <typeparam name="TFieldValue"></typeparam>
		/// <param name="entityId"></param>
		/// <param name="propertyExpression"></param>
		/// <param name="dictionaryKey"></param>
		/// <returns></returns>
		Task<TFieldValue> GetDictionaryFieldValueAsync<TFieldValue>(string entityId, Expression<Func<T, object>> propertyExpression,
		                                                                                        object dictionaryKey);

		///  <summary>
		/// 		Sets the value for the Dictionary item located at the given dictionaryKey
		///  </summary>
		///  <typeparam name="TFieldValue"></typeparam>
		/// <param name="entityId"></param>
		/// <param name="propertyExpression"></param>
		/// <param name="dictionaryKey"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		Task SetDictionaryFieldValueAsync<TFieldValue>(string entityId, Expression<Func<T, object>> propertyExpression, object dictionaryKey,
		                                                                     TFieldValue value);
	}
}